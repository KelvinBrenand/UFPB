1) O que é programação concorrente? Quais são os aspectos a serem observados quando do planejamento de sistemas que utilizam processos concorrentes?
R: Programação concorrente é um método de desenvolvimento de software originado na década de 60 que divide a tarefa de um programa em duas ou mais threads (multithread), ao invés de apenas uma (singlethread). Este método é empregado quando se busca deixar um programa mais eficiente. Mas essa eficiência vem com um custo: Programadores que fazem uso de programação concorrente devem estar atentos a comunicação de programas multithread, pois esta pode se tornar uma fonte de problemas. Além disso, a própria natureza dinâmica da progrmação multithread a torma mais complexa se comparada com a programação habitual. E isso é especialemente notório na etapa de tratamento de bugs.

2) Qual o impacto do advento dos processadores multi-núcleo na implementação e execução de programas que utilizam programação concorrente? 
R: Com o advento dos processadores multi-núcleo, o processador pode executar diferentes instruções de um programa ao mesmo tempo em seus diferentes núcleos. Essa tecnologia é capaz de aumentar drasticamente o desenpenho de programas, em especial dos que usam programação concorrente. Essa característica dos processadores multi-núcleo fez com que eles se tornassem o padrão do mercado.

3) O que é, em programação concorrente, consistência de memória?
R: A consistência de memória especifica a ordem de cargas e armazenamentos em diferentes locais da memória. É uma espécie de "contrato" entre o hardware, o compilador e o programador, ou seja, o hardware e o compilador não violarão o pedido especificado e o programador não assumirá uma ordem mais estrita do que a do modelo.

4) O que é um processo? Quais são as informações que compreendem o contexto de um processo? 
R: Um processo é a instância de um programa que está sendo executado por um ou mais threads. O contexto de um processo compreende o código do programa, os dados armazenados na memória, a pilha de execução, o conteúdo dos registradores e os descritores dos arquivos abertos.

5) Faça um programa em C/C++ que declare uma variável global do tipo double; faça o programa criar 10 threads e passe para essas threads um valor inteiro que represente um índice único (de 0 a 9). Faça cada uma das threads realizar uma função que verifique se seu identificador é par ou ímpar. Caso o identificador seja par, a função deve realizar um laço de repetição que faça 10 incrementos (+1) na variável global; caso o identificador seja ímpar, a função deve realizar um laço que faça 10 decrementos (-1) na variável global. A cada iteração a função deve exibir o identificador da thread e o novo valor da variável global, além de dormir um tempo aleatório entre 1s e 4s. Após o término de todas as threads, exiba o valor final da variável global na thread principal. Comente o código explicando o conceito de concorrência (e suas diferentes formas de realização nos atuais sistemas). Explique quais são os elementos do Sistema Operacional e da arquitetura do computador envolvidos   na   execução   do   programa   e   como   se   comportam   para   que   a   lógica   implementada   seja concorrente. Fale também sobre consistência de memória (à luz da execução do código implementado).

6) Faça um programa em C/C++ em que você compare o tempo de criação de 30 threads e 30 processos, onde as threads e processos criadas apenas executem uma função que exiba uma mensagem ("Nova thread" ou "Novo processo") e as faça dormir por 2s. Use alguma função de medição de tempo* para tal e escreva suas impressões sobre o resultado, justificando qual das opções demandou menos tempo de execução para ser realizada e faça a relação disso com consumo de processamento e memória. Inclua junto ao código um print de uma execução do programa. Para finalizar, faça uma clara distinção (em comentários no código) das diferenças principais entre threads e processos. Ao término do programa, nenhum processo deverá permanecer em execução.

* Funções sugeridas para uso no processo de medição de tempo de execução são listadas abaixo.Em C/C++: time(),  clock(), clock_gettime() (biblioteca time.h), gettimeofday() (biblioteca sys/time.h);Em C++: método chrono::high_resolution_clock (biblioteca chrono).

 
